package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
    public Symbol getErrorSymbol() {
        return new Symbol(sym.error);
    }
    
:}

init with {: 
	errorDetected=false; 
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



terminal PROG, CONST, EQUALS, SEMICOLON, COMMA, VOID, IF, BREAK, CONTINUE, RETURN, READ, PRINT, DO, WHILE, ELSE, OR, AND, INCREMENT, DECREMENT, DOT;
terminal LEFT_SQUARE_PARENTHESES, RIGHT_SQUARE_PARENTHESES, LEFT_ROUND_PARENTHESES, RIGHT_ROUND_PARENTHESES, LEFT_WIGGLY_PARENTHESES, RIGHT_WIGGLY_PARENTHESES;
terminal MAP, MINUS, PLUS, UNION, EQUALS_EQUALS, NOT_EQUALS, GT, GTE, LT, LTE, MUL, DIV, PERCENT, NEW;
terminal INTERFACE, EXTENDS, CLASS, COLON;
terminal String IDENT;
terminal Integer NUM_CONST;
terminal Boolean BOOL_CONST;
terminal Character CHAR_CONST;

nonterminal DeclList DeclList;
nonterminal MethodDeclList MethodDeclList;
nonterminal VarDecl VarDecl;
nonterminal ConstDecl ConstDecl;
nonterminal FirstConst FirstConst;
nonterminal ConstList ConstList;
nonterminal ListElems ListElems;
nonterminal Type Type;
nonterminal VarAssign VarAssign;
nonterminal VarAssignList VarAssignList;

nonterminal FormParsOptional FormParsOptional;
nonterminal VarDecList VarDecList;
nonterminal StatementList StatementList;
nonterminal FormPars FormPars;
nonterminal Param Param;
nonterminal FormParsList FormParsList;
nonterminal Statement Statement;
nonterminal ElseOption ElseOption;
nonterminal ExprOption ExprOption;
nonterminal StatementListVar StatementListVar;
nonterminal Condition Condition;
nonterminal CondTermORList CondTermORList;
nonterminal Expr Expr;
nonterminal ExprStartOpt ExprStartOpt;
nonterminal AddOp AddOp;
nonterminal ExprAddopList ExprAddopList;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ActParsOpt ActParsOpt;
nonterminal Designator Designator;
nonterminal AssignOp AssignOp;
nonterminal SetOp SetOp;
nonterminal ActPars ActPars;
nonterminal ExprList ExprList;
nonterminal CondTerm CondTerm;
nonterminal CondFactANDList CondFactANDList;
nonterminal CondFact CondFact;
nonterminal RelopExprOption RelopExprOption;
nonterminal Term Term;
nonterminal Factor Factor;
nonterminal RelOp RelOp;
nonterminal MulOp MulOp;
nonterminal Label Label;
nonterminal ThreeDesignList ThreeDesignList;
nonterminal Decl Decl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, MethodStart, MethodSignature, MethodDecl;

precedence left ELSE;

Program ::= (Program) PROG ProgName:p DeclList:D1 LEFT_WIGGLY_PARENTHESES MethodDeclList:M2 RIGHT_WIGGLY_PARENTHESES {: RESULT=new Program(p, D1, M2); RESULT.setLine(pleft); :};
ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :}; 

DeclList ::= (Declarations) DeclList:D1 Decl:D2 {: RESULT=new Declarations(D1, D2); RESULT.setLine(D1left); :}
			|
			(NoDeclarations) {: RESULT=new NoDeclarations(); :} /* epsilon */
			;
			
Decl ::= (ConstDeclaration) ConstDecl:C1 {: RESULT=new ConstDeclaration(C1); RESULT.setLine(C1left); :}
	   | (VarDeclaration) VarDecl:V1 {: RESULT=new VarDeclaration(V1); RESULT.setLine(V1left); :}
	   ;
			
MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
				| (NoMethodDeclarations) {: RESULT=new NoMethodDeclarations(); :} /* epsilon */
				;
				
ConstDecl ::= (ConstDecl) CONST Type:T1 ConstList:C2 SEMICOLON {: RESULT=new ConstDecl(T1, C2); RESULT.setLine(T1left); :};

FirstConst ::= (ConstNum) NUM_CONST:valueNum {: RESULT=new ConstNum(valueNum); RESULT.setLine(valueNumleft); :}
			| (ConstChar) CHAR_CONST:valueChar {: RESULT=new ConstChar(valueChar); RESULT.setLine(valueCharleft); :}
			| (ConstBool) BOOL_CONST:valueBool {: RESULT=new ConstBool(valueBool); RESULT.setLine(valueBoolleft); :}
			;
			
ConstList ::= (ConstantList) ConstList:C1 COMMA ListElems:L2 {: RESULT=new ConstantList(C1, L2); RESULT.setLine(C1left); :} 		
			|
			(SingleConstAssign) ListElems:L1 {: RESULT=new SingleConstAssign(L1); RESULT.setLine(L1left); :}
			;	
			
ListElems ::= (ListElems) IDENT:name EQUALS FirstConst:F1 {: RESULT=new ListElems(name, F1); RESULT.setLine(nameleft); :}	;		

Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};

VarDecl ::= (VariableDecl) Type:varType VarAssignList:V1 SEMICOLON {: RESULT=new VariableDecl(varType, V1); RESULT.setLine(varTypeleft); :}
		 | (VarDeclError)  error SEMICOLON:l
		 {: parser.report_error("Oporavak od greske pri definiciji globalne promenljive na liniji " + lleft, null); :} {: RESULT=new VarDeclError(); :}
		 ;

VarAssign ::= (VarAssign_var) IDENT:varName {: RESULT=new VarAssign_var(varName); RESULT.setLine(varNameleft); :}
            | (VarAssign_array) IDENT:varName LEFT_SQUARE_PARENTHESES RIGHT_SQUARE_PARENTHESES {: RESULT=new VarAssign_array(varName); RESULT.setLine(varNameleft); :}
            ;
					
VarAssignList ::= (RestVariableDecl) VarAssignList:V1 COMMA VarAssign:V2 {: RESULT=new RestVariableDecl(V1, V2); RESULT.setLine(V1left); :} 			
			|
			(SingleVarAssign) VarAssign:V1 {: RESULT=new SingleVarAssign(V1); RESULT.setLine(V1left); :}
			;	

MethodSignature ::= (MethodSignature) MethodStart:M1 LEFT_ROUND_PARENTHESES FormParsOptional:F2 RIGHT_ROUND_PARENTHESES {: RESULT=new MethodSignature(M1, F2); RESULT.setLine(M1left); :};

MethodStart ::= (MethodStartType) Type:T1 IDENT:name {: RESULT=new MethodStartType(T1, name); RESULT.setLine(T1left); :}
			|
			(MethodStartVoid) VOID IDENT:name {: RESULT=new MethodStartVoid(name); RESULT.setLine(nameleft); :}
			;	
			
FormParsOptional ::= (FormalParsOptional) FormPars:F1 {: RESULT=new FormalParsOptional(F1); RESULT.setLine(F1left); :}			
			|
			(NoFormParsOptional) {: RESULT=new NoFormParsOptional(); :} /* epsilon */
			;	
			
MethodDecl ::= (MethodDecl)	MethodSignature:M1 VarDecList:V2 LEFT_WIGGLY_PARENTHESES StatementList:S3 RIGHT_WIGGLY_PARENTHESES {: RESULT=new MethodDecl(M1, V2, S3); RESULT.setLine(M1left); :};

VarDecList ::= (VariableDeclList) VarDecList:V1 VarDecl:V2 {: RESULT=new VariableDeclList(V1, V2); RESULT.setLine(V1left); :}	
			|
			(NoVarDecList) {: RESULT=new NoVarDecList(); :} /* epsilon */
			;			
			
StatementList  ::= (StatementListGlobal) StatementList:S1 Statement:S2 {: RESULT=new StatementListGlobal(S1, S2); RESULT.setLine(S1left); :}	
			|
			(NoStatementList) {: RESULT=new NoStatementList(); :} /* epsilon */
			;				
			
FormPars  ::= (FormPars) FormParsList:F1 {: RESULT=new FormPars(F1); RESULT.setLine(F1left); :};

Param  ::= (Param_var) Type:T1 IDENT:name {: RESULT=new Param_var(T1, name); RESULT.setLine(T1left); :} 
		| (Param_array) Type:T1 IDENT:name LEFT_SQUARE_PARENTHESES RIGHT_SQUARE_PARENTHESES {: RESULT=new Param_array(T1, name); RESULT.setLine(T1left); :}
		;

FormParsList  ::= (FormalParsList) FormParsList:F1 COMMA Param:P2 {: RESULT=new FormalParsList(F1, P2); RESULT.setLine(F1left); :}
			|
			(SingleParam) Param:P1 {: RESULT=new SingleParam(P1); RESULT.setLine(P1left); :}
			;
			
			
Statement  ::= (DesignatorStmt) DesignatorStatement:D1 SEMICOLON {: RESULT=new DesignatorStmt(D1); RESULT.setLine(D1left); :}
			| (IfElseStmt) IF LEFT_ROUND_PARENTHESES Condition:C1 RIGHT_ROUND_PARENTHESES Statement:S2 ElseOption:E3 {: RESULT=new IfElseStmt(C1, S2, E3); RESULT.setLine(C1left); :}
			| (BreakStmt) BREAK SEMICOLON {: RESULT=new BreakStmt(); :}
			| (ContinueStmt) CONTINUE SEMICOLON {: RESULT=new ContinueStmt(); :}
			| (ReturnStmt) RETURN ExprOption:E1 SEMICOLON {: RESULT=new ReturnStmt(E1); RESULT.setLine(E1left); :}
			| (ReadStmt) READ LEFT_ROUND_PARENTHESES Designator:D1 RIGHT_ROUND_PARENTHESES SEMICOLON {: RESULT=new ReadStmt(D1); RESULT.setLine(D1left); :} 
			| (PrintStmt) PRINT LEFT_ROUND_PARENTHESES Expr:E1 RIGHT_ROUND_PARENTHESES SEMICOLON {: RESULT=new PrintStmt(E1); RESULT.setLine(E1left); :}         
			| (PrintStmt1) PRINT LEFT_ROUND_PARENTHESES Expr:E1 COMMA NUM_CONST:N2 RIGHT_ROUND_PARENTHESES SEMICOLON {: RESULT=new PrintStmt1(E1, N2); RESULT.setLine(E1left); :}  
			| (StmtList) LEFT_WIGGLY_PARENTHESES StatementListVar:S1 RIGHT_WIGGLY_PARENTHESES {: RESULT=new StmtList(S1); RESULT.setLine(S1left); :}
			| (DoWhileStmt) DO Statement:S1 WHILE LEFT_ROUND_PARENTHESES RIGHT_ROUND_PARENTHESES SEMICOLON {: RESULT=new DoWhileStmt(S1); RESULT.setLine(S1left); :} 
			| (DoWhileStmtWithCondition) DO Statement:S1 WHILE LEFT_ROUND_PARENTHESES Condition:C2 RIGHT_ROUND_PARENTHESES SEMICOLON {: RESULT=new DoWhileStmtWithCondition(S1, C2); RESULT.setLine(S1left); :} 
			| (DoWhileStmtWithDesignatorStmt) DO Statement:S1 WHILE LEFT_ROUND_PARENTHESES Condition:C2 COMMA DesignatorStatement:D3 RIGHT_ROUND_PARENTHESES SEMICOLON {: RESULT=new DoWhileStmtWithDesignatorStmt(S1, C2, D3); RESULT.setLine(S1left); :} 
			| (ErrorStmt)  error SEMICOLON:l
			{: parser.report_error("Oporavak od greske pri dodeli vrednosti na liniji " + lleft, null); :} {: RESULT=new ErrorStmt(); :}
			;
			
			
			
ElseOption  ::= (ElseOptionStmt) ELSE Statement:S1 {: RESULT=new ElseOptionStmt(S1); RESULT.setLine(S1left); :}
 			 | (NoElseStmt) {: RESULT=new NoElseStmt(); :} /* epsilon */
			 ;			
			                    
ExprOption  ::= (ExprOptionStmt) Expr:E1 {: RESULT=new ExprOptionStmt(E1); RESULT.setLine(E1left); :}			                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
 			 | (NoExprStmt) {: RESULT=new NoExprStmt(); :} /* epsilon */
			 ;	

StatementListVar ::= (StatmntList) StatementListVar:S1 Statement:S2 {: RESULT=new StatmntList(S1, S2); RESULT.setLine(S1left); :}
 			   | (NoStatements) {: RESULT=new NoStatements(); :} /* epsilon */
			   ;	

Condition ::= (Condition) CondTerm:C1 CondTermORList:C2 {: RESULT=new Condition(C1, C2); RESULT.setLine(C1left); :};

CondTermORList ::= (OrConditionList) CondTermORList:C1 OR CondTerm:C2 {: RESULT=new OrConditionList(C1, C2); RESULT.setLine(C1left); :}
 			   | (NoOrConditionList) {: RESULT=new NoOrConditionList(); :} /* epsilon */
			   ;	

Expr ::= (ExprFirstOpt) ExprStartOpt:E1 ExprAddopList:E2 {: RESULT=new ExprFirstOpt(E1, E2); RESULT.setLine(E1left); :}
      | (ExprDesignator) Designator:D1 MAP Designator:D2 {: RESULT=new ExprDesignator(D1, D2); RESULT.setLine(D1left); :}
      ;    

      
ExprStartOpt ::= (ExprStartWithoutMinus) Term:t {: RESULT=new ExprStartWithoutMinus(t); RESULT.setLine(tleft); :}
 			   | (ExprStartWithMinus) MINUS Term:t {: RESULT=new ExprStartWithMinus(t); RESULT.setLine(tleft); :}
			   ;	
AddOp ::= (Plus) PLUS {: RESULT=new Plus(); :}
       | (Minus) MINUS {: RESULT=new Minus(); :}
       ;
ExprAddopList ::= (ExprAddopListGlobal) ExprAddopList:E1 AddOp:A2 Term:t {: RESULT=new ExprAddopListGlobal(E1, A2, t); RESULT.setLine(E1left); :}
 		  | (NoExprAddopList) {: RESULT=new NoExprAddopList(); :} /* epsilon */
		  ;	

DesignatorStatement ::= (DesignAssignExpr) Designator:D1 AssignOp:A2 Expr:E3 {: RESULT=new DesignAssignExpr(D1, A2, E3); RESULT.setLine(D1left); :}
					 | (DesignFunctionCalling) Designator:D1 LEFT_ROUND_PARENTHESES ActParsOpt:A2 RIGHT_ROUND_PARENTHESES {: RESULT=new DesignFunctionCalling(D1, A2); RESULT.setLine(D1left); :}
					 | (DesignIncrement) Designator:D1 INCREMENT {: RESULT=new DesignIncrement(D1); RESULT.setLine(D1left); :}
					 | (DesignDecrement) Designator:D1 DECREMENT {: RESULT=new DesignDecrement(D1); RESULT.setLine(D1left); :}
					 | (DesignAssign) ThreeDesignList:T1 {: RESULT=new DesignAssign(T1); RESULT.setLine(T1left); :}
					 ;

ThreeDesignList ::= (ThreeDesignList) Designator:D1 AssignOp:A2 Designator:D3 SetOp:S4 Designator:D5 {: RESULT=new ThreeDesignList(D1, A2, D3, S4, D5); RESULT.setLine(D1left); :};
					 
					 
ActParsOpt ::= (ActualParameterList) ActPars:A1 {: RESULT=new ActualParameterList(A1); RESULT.setLine(A1left); :}
 			 | (NoActualParameter) {: RESULT=new NoActualParameter(); :} /* epsilon */
			 ;	
			   
Designator ::= (DesignIdent) IDENT:varName {: RESULT=new DesignIdent(varName); RESULT.setLine(varNameleft); :}
            | (DesignArr) Designator:D1 LEFT_SQUARE_PARENTHESES Expr:expr RIGHT_SQUARE_PARENTHESES {: RESULT=new DesignArr(D1, expr); RESULT.setLine(D1left); :}
            | (DesignClass) Designator:D1 DOT IDENT:classVar {: RESULT=new DesignClass(D1, classVar); RESULT.setLine(D1left); :}
            ;
            
AssignOp ::= (AssignOp) EQUALS {: RESULT=new AssignOp(); :} ;

SetOp ::= (SetOp) UNION {: RESULT=new SetOp(); :};

ActPars ::= (ActPars) Expr:E1 ExprList:E2 {: RESULT=new ActPars(E1, E2); RESULT.setLine(E1left); :};

ExprList ::= (ExpressionList) ExprList:E1 COMMA Expr:E2 {: RESULT=new ExpressionList(E1, E2); RESULT.setLine(E1left); :}
			| (NoExpressionList) {: RESULT=new NoExpressionList(); :}  /* epsilon */
			;         			   
					 
CondTerm ::= (CondTerm) CondFact:C1 CondFactANDList:C2 {: RESULT=new CondTerm(C1, C2); RESULT.setLine(C1left); :};
CondFactANDList ::= (AndConditionList) CondFactANDList:C1 AND CondFact:C2 {: RESULT=new AndConditionList(C1, C2); RESULT.setLine(C1left); :}
			     | (NoAndConditionList) {: RESULT=new NoAndConditionList(); :}  /* epsilon */
			     ; 
CondFact ::= (CondFact) Expr:E1 RelopExprOption:R2 {: RESULT=new CondFact(E1, R2); RESULT.setLine(E1left); :};

RelopExprOption ::= (RelationOpWithExpression) RelOp:R1 Expr:E2 {: RESULT=new RelationOpWithExpression(R1, E2); RESULT.setLine(R1left); :}
                 | (NoRelationOp) {: RESULT=new NoRelationOp(); :}  /* epsilon */
			     ;  
			     
Term ::= (TermFactor) Factor:F1 {: RESULT=new TermFactor(F1); RESULT.setLine(F1left); :}
	  | (TermMulop) Term:T1 MulOp:M2 Factor:F3 {: RESULT=new TermMulop(T1, M2, F3); RESULT.setLine(T1left); :}
	  ;
	  
Factor ::= (NumFactor) NUM_CONST:N1 {: RESULT=new NumFactor(N1); RESULT.setLine(N1left); :}
        | (CharFactor) CHAR_CONST:C1 {: RESULT=new CharFactor(C1); RESULT.setLine(C1left); :}
        | (BoolFactor) BOOL_CONST:B1 {: RESULT=new BoolFactor(B1); RESULT.setLine(B1left); :}
        | (ExprFactor) LEFT_ROUND_PARENTHESES Expr:ex RIGHT_ROUND_PARENTHESES {: RESULT=new ExprFactor(ex); RESULT.setLine(exleft); :}	  
        | (DesignatorVar) Designator:des {: RESULT=new DesignatorVar(des); RESULT.setLine(desleft); :}
        | (DesignatorFuncCall) Designator:D1 LEFT_ROUND_PARENTHESES ActParsOpt:A2 RIGHT_ROUND_PARENTHESES {: RESULT=new DesignatorFuncCall(D1, A2); RESULT.setLine(D1left); :}
        | (ArrayFactor) NEW Type:arrtype LEFT_SQUARE_PARENTHESES Expr:ex RIGHT_SQUARE_PARENTHESES {: RESULT=new ArrayFactor(arrtype, ex); RESULT.setLine(arrtypeleft); :}
        | (ClassFactor) NEW Type:T1 LEFT_ROUND_PARENTHESES ActParsOpt:A2 RIGHT_ROUND_PARENTHESES {: RESULT=new ClassFactor(T1, A2); RESULT.setLine(T1left); :}
        ;

RelOp ::= (EqualsEquals) EQUALS_EQUALS {: RESULT=new EqualsEquals(); :}
       | (NonEquals) NOT_EQUALS {: RESULT=new NonEquals(); :}
       | (Greater) GT {: RESULT=new Greater(); :}
       | (GreaterEqual) GTE {: RESULT=new GreaterEqual(); :}
       | (LessThen) LT {: RESULT=new LessThen(); :}
       | (LessThenEqual) LTE {: RESULT=new LessThenEqual(); :}
       ;
       
MulOp ::= (MulopOp) MUL {: RESULT=new MulopOp(); :}
       | (DivOp) DIV {: RESULT=new DivOp(); :}
       | (Percent) PERCENT {: RESULT=new Percent(); :}
       ;
      
Label ::= (Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :};                   
