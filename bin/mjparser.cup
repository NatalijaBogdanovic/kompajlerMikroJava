package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
    public Symbol getErrorSymbol() {
        return new Symbol(sym.error);
    }
    
:}

init with {: 
	errorDetected=false; 
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



terminal PROG, CONST, EQUALS, SEMICOLON, COMMA, VOID, IF, BREAK, CONTINUE, RETURN, READ, PRINT, DO, WHILE, ELSE, OR, AND, INCREMENT, DECREMENT, DOT;
terminal LEFT_SQUARE_PARENTHESES, RIGHT_SQUARE_PARENTHESES, LEFT_ROUND_PARENTHESES, RIGHT_ROUND_PARENTHESES, LEFT_WIGGLY_PARENTHESES, RIGHT_WIGGLY_PARENTHESES;
terminal MAP, MINUS, PLUS, UNION, EQUALS_EQUALS, NOT_EQUALS, GT, GTE, LT, LTE, MUL, DIV, PERCENT, NEW;
terminal INTERFACE, EXTENDS, CLASS, COLON;
terminal String IDENT;
terminal Integer NUM_CONST;
terminal Boolean BOOL_CONST;
terminal Character CHAR_CONST;

nonterminal DeclList, MethodDeclList, VarDecl, ConstDecl, FirstConst, ConstList, ListElems, Type, VarAssign, VarAssignList;

nonterminal FormParsOptional, VarDecList, StatementList, FormPars, Param, FormParsList, Statement, ElseOption, ExprOption;
nonterminal StatementListVar, Condition, CondTermORList, Expr, ExprStartOpt, AddOp, ExprAddopList, DesignatorStatement, ActParsOpt, Designator, AssignOp, SetOp;
nonterminal ActPars, ExprList, CondTerm, CondFactANDList, CondFact, RelopExprOption, Term, Factor, RelOp, MulOp, Label;
nonterminal ThreeDesignList, Decl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, MethodStart, MethodSignature, MethodDecl;

precedence left ELSE;

Program ::= (Program) PROG ProgName:p DeclList LEFT_WIGGLY_PARENTHESES MethodDeclList RIGHT_WIGGLY_PARENTHESES;
ProgName ::= (ProgName) IDENT:progName; 

DeclList ::= (Declarations) DeclList Decl
			|
			(NoDeclarations) /* epsilon */
			;
			
Decl ::= (ConstDeclaration) ConstDecl
	   | (VarDeclaration) VarDecl
	   ;
			
MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
				| (NoMethodDeclarations) /* epsilon */
				;
				
ConstDecl ::= (ConstDecl) CONST Type ConstList SEMICOLON;

FirstConst ::= (ConstNum) NUM_CONST:valueNum
			| (ConstChar) CHAR_CONST:valueChar
			| (ConstBool) BOOL_CONST:valueBool
			;
			
ConstList ::= (ConstantList) ConstList COMMA ListElems 		
			|
			(SingleConstAssign) ListElems
			;	
			
ListElems ::= (ListElems) IDENT:name EQUALS FirstConst	;		

Type ::= (Type) IDENT:typeName;

VarDecl ::= (VariableDecl) Type:varType VarAssignList SEMICOLON
		 | (VarDeclError)  error SEMICOLON:l
		 {: parser.report_error("Oporavak od greske pri definiciji globalne promenljive na liniji " + lleft, null); :}
		 ;

VarAssign ::= (VarAssign_var) IDENT:varName
            | (VarAssign_array) IDENT:varName LEFT_SQUARE_PARENTHESES RIGHT_SQUARE_PARENTHESES
            ;
					
VarAssignList ::= (RestVariableDecl) VarAssignList COMMA VarAssign 			
			|
			(SingleVarAssign) VarAssign
			;	

MethodSignature ::= (MethodSignature) MethodStart LEFT_ROUND_PARENTHESES FormParsOptional RIGHT_ROUND_PARENTHESES;

MethodStart ::= (MethodStartType) Type IDENT:name
			|
			(MethodStartVoid) VOID IDENT:name
			;	
			
FormParsOptional ::= (FormalParsOptional) FormPars			
			|
			(NoFormParsOptional) /* epsilon */
			;	
			
MethodDecl ::= (MethodDecl)	MethodSignature VarDecList LEFT_WIGGLY_PARENTHESES StatementList RIGHT_WIGGLY_PARENTHESES;

VarDecList ::= (VariableDeclList) VarDecList VarDecl	
			|
			(NoVarDecList) /* epsilon */
			;			
			
StatementList  ::= (StatementListGlobal) StatementList Statement	
			|
			(NoStatementList) /* epsilon */
			;				
			
FormPars  ::= (FormPars) FormParsList;

Param  ::= (Param_var) Type IDENT:name 
		| (Param_array) Type IDENT:name LEFT_SQUARE_PARENTHESES RIGHT_SQUARE_PARENTHESES
		;

FormParsList  ::= (FormalParsList) FormParsList COMMA Param
			|
			(SingleParam) Param
			;
			
			
Statement  ::= (DesignatorStmt) DesignatorStatement SEMICOLON
			| (IfElseStmt) IF LEFT_ROUND_PARENTHESES Condition RIGHT_ROUND_PARENTHESES Statement ElseOption
			| (BreakStmt) BREAK SEMICOLON
			| (ContinueStmt) CONTINUE SEMICOLON
			| (ReturnStmt) RETURN ExprOption SEMICOLON
			| (ReadStmt) READ LEFT_ROUND_PARENTHESES Designator RIGHT_ROUND_PARENTHESES SEMICOLON 
			| (PrintStmt) PRINT LEFT_ROUND_PARENTHESES Expr RIGHT_ROUND_PARENTHESES SEMICOLON         
			| (PrintStmt1) PRINT LEFT_ROUND_PARENTHESES Expr COMMA NUM_CONST RIGHT_ROUND_PARENTHESES SEMICOLON  
			| (StmtList) LEFT_WIGGLY_PARENTHESES StatementListVar RIGHT_WIGGLY_PARENTHESES
			| (DoWhileStmt) DO Statement WHILE LEFT_ROUND_PARENTHESES RIGHT_ROUND_PARENTHESES SEMICOLON 
			| (DoWhileStmtWithCondition) DO Statement WHILE LEFT_ROUND_PARENTHESES Condition RIGHT_ROUND_PARENTHESES SEMICOLON 
			| (DoWhileStmtWithDesignatorStmt) DO Statement WHILE LEFT_ROUND_PARENTHESES Condition COMMA DesignatorStatement RIGHT_ROUND_PARENTHESES SEMICOLON 
			| (ErrorStmt)  error SEMICOLON:l
			{: parser.report_error("Oporavak od greske pri dodeli vrednosti na liniji " + lleft, null); :}
			;
			
			
			
ElseOption  ::= (ElseOptionStmt) ELSE Statement
 			 | (NoElseStmt) /* epsilon */
			 ;			
			                    
ExprOption  ::= (ExprOptionStmt) Expr			                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
 			 | (NoExprStmt) /* epsilon */
			 ;	

StatementListVar ::= (StatmntList) StatementListVar Statement
 			   | (NoStatements) /* epsilon */
			   ;	

Condition ::= (Condition) CondTerm CondTermORList;

CondTermORList ::= (OrConditionList) CondTermORList OR CondTerm
 			   | (NoOrConditionList) /* epsilon */
			   ;	

Expr ::= (ExprFirstOpt) ExprStartOpt ExprAddopList
      | (ExprDesignator) Designator MAP Designator
      ;    

      
ExprStartOpt ::= (ExprStartWithoutMinus) Term:t
 			   | (ExprStartWithMinus) MINUS Term:t
			   ;	
AddOp ::= (Plus) PLUS
       | (Minus) MINUS
       ;
ExprAddopList ::= (ExprAddopListGlobal) ExprAddopList AddOp Term:t
 		  | (NoExprAddopList) /* epsilon */
		  ;	

DesignatorStatement ::= (DesignAssignExpr) Designator AssignOp Expr
					 | (DesignFunctionCalling) Designator LEFT_ROUND_PARENTHESES ActParsOpt RIGHT_ROUND_PARENTHESES
					 | (DesignIncrement) Designator INCREMENT
					 | (DesignDecrement) Designator DECREMENT
					 | (DesignAssign) ThreeDesignList
					 ;

ThreeDesignList ::= (ThreeDesignList) Designator AssignOp Designator SetOp Designator;
					 
					 
ActParsOpt ::= (ActualParameterList) ActPars
 			 | (NoActualParameter) /* epsilon */
			 ;	
			   
Designator ::= (DesignIdent) IDENT:varName
            | (DesignArr) Designator LEFT_SQUARE_PARENTHESES Expr:expr RIGHT_SQUARE_PARENTHESES
            | (DesignClass) Designator DOT IDENT:classVar
            ;
            
AssignOp ::= (AssignOp) EQUALS ;

SetOp ::= (SetOp) UNION;

ActPars ::= (ActPars) Expr ExprList;

ExprList ::= (ExpressionList) ExprList COMMA Expr
			| (NoExpressionList)  /* epsilon */
			;         			   
					 
CondTerm ::= (CondTerm) CondFact CondFactANDList;
CondFactANDList ::= (AndConditionList) CondFactANDList AND CondFact
			     | (NoAndConditionList)  /* epsilon */
			     ; 
CondFact ::= (CondFact) Expr RelopExprOption;

RelopExprOption ::= (RelationOpWithExpression) RelOp Expr
                 | (NoRelationOp)  /* epsilon */
			     ;  
			     
Term ::= (TermFactor) Factor
	  | (TermMulop) Term MulOp Factor
	  ;
	  
Factor ::= (NumFactor) NUM_CONST
        | (CharFactor) CHAR_CONST
        | (BoolFactor) BOOL_CONST
        | (ExprFactor) LEFT_ROUND_PARENTHESES Expr:ex RIGHT_ROUND_PARENTHESES	  
        | (DesignatorVar) Designator:des
        | (DesignatorFuncCall) Designator LEFT_ROUND_PARENTHESES ActParsOpt RIGHT_ROUND_PARENTHESES
        | (ArrayFactor) NEW Type:arrtype LEFT_SQUARE_PARENTHESES Expr:ex RIGHT_SQUARE_PARENTHESES
        | (ClassFactor) NEW Type LEFT_ROUND_PARENTHESES ActParsOpt RIGHT_ROUND_PARENTHESES
        ;

RelOp ::= (EqualsEquals) EQUALS_EQUALS
       | (NonEquals) NOT_EQUALS
       | (Greater) GT
       | (GreaterEqual) GTE
       | (LessThen) LT
       | (LessThenEqual) LTE
       ;
       
MulOp ::= (MulopOp) MUL
       | (DivOp) DIV
       | (Percent) PERCENT
       ;
      
Label ::= (Label) IDENT;                   
